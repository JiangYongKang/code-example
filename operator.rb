#!/usr/bin/ruby
# -*- coding: utf-8 -*-

# 大多数运算符实际上是方法调用。
# 例如，a + b 被解释为 a.+(b)，其中指向变量 a 的 + 方法被调用，b 作为方法调用的参数。

# 算术运算符
a, b = 10, 5
puts "------------------------------------------------------------------------------------------------------------------------------------------------"
puts "算术运算符"
puts "a + b =  #{a + b}"   # 加法 - 把运算符两边的操作数相加
puts "a - b =  #{a - b}"   # 减法 - 把左操作数减去右操作数
puts "a * b =  #{a * b}"   # 乘法 - 把运算符两边的操作数相乘
puts "a / b =  #{a / b}"   # 除法 - 把左操作数除以右操作数
puts "a % b =  #{a % b}"   # 求模 - 把左操作数除以右操作数，返回余数
puts "a ** b = #{a ** b}"  # 指数 - 执行指数计算

# 比较运算符
a, b = 10, 5
puts "------------------------------------------------------------------------------------------------------------------------------------------------"
puts "比较运算符"
puts "a == b:      #{a == b}"      # 检查两个操作数的值是否相等，如果相等则条件为真。
puts "a != b:      #{a != b}"      # 检查两个操作数的值是否相等，如果不相等则条件为真。
puts "a > b:       #{a > b}"       # 检查左操作数的值是否大于右操作数的值，如果是则条件为真。
puts "a < b:       #{a < b}"       # 检查左操作数的值是否小于右操作数的值，如果是则条件为真。
puts "a >= b:      #{a >= b}"      # 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。
puts "a <= b:      #{a <= b}"      # 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。
puts "a <=> b:     #{a <=> b}"     # 联合比较运算符。如果第一个操作数等于第二个操作数则返回 0，如果第一个操作数大于第二个操作数则返回 1，如果第一个操作数小于第二个操作数则返回 -1。
puts "a === b:     #{a === b}"     # 用于测试 case 语句的 when 子句内的相等。(1...10) === 5 返回 true。
puts "1.eql?(1.0): #{1.eql?(1.0)}" # 如果接收器和参数具有相同的类型和相等的值，则返回 true。1 == 1.0 返回 true，但是 1.eql?(1.0) 返回 false。
puts "a.equal?b:   #{a.equal?b}"   # 如果接收器和参数具有相同的对象 id，则返回 true。如果 a 是 b 的副本，那么 a == b 返回 true，a.equal?b 返回 false，但是 a.equal?a 返回 true。


# 赋值运算符
a, b = 10, 5
puts "------------------------------------------------------------------------------------------------------------------------------------------------"
puts "赋值运算符"
puts "c = a + b:   #{c = a + b}" # 简单的赋值运算符，把右操作数的值赋给左操作数
puts "c += a:      #{c += a}"    # 加且赋值运算符，把右操作数加上左操作数的结果赋值给左操作数
puts "c -= a:      #{c -= a}"    # 减且赋值运算符，把左操作数减去右操作数的结果赋值给左操作数
puts "c *= a:      #{c *= a}"    # 乘且赋值运算符，把右操作数乘以左操作数的结果赋值给左操作数
puts "c /= a:      #{c /= a}"    # 除且赋值运算符，把左操作数除以右操作数的结果赋值给左操作数
puts "c %= a:      #{c %= a}"    # 求模且赋值运算符，求两个操作数的模赋值给左操作数
puts "c **= a:     #{c **= a}"   # 指数且赋值运算符，执行指数计算，并赋值给左操作数

# 并行赋值
a, b, c = 10, 20, 30
puts "------------------------------------------------------------------------------------------------------------------------------------------------"
puts "并行赋值"
puts "a, b, c: #{a} #{b} #{c}"
a, b = [1, 2, 3, 4]
puts "a, b = #{a} #{b}"
a, *b = [1, 2, 3, 4]
puts "a, b = #{a} #{b}"
a, b = 99, [1, 2, 3, 4]
puts "a, b = #{a} #{b}"
a, *b = 99, [1, 2, 3, 4]
puts "a, b = #{a} #{b}"
a, b = 99, *[1, 2, 3, 4]
puts "a, b = #{a} #{b}"
a, *b = 99, *[1, 2, 3, 4]
puts "a, b = #{a} #{b}"
a, (b, c), d = 1, 2, 3, 4
puts "a, b, c, d = #{a} #{b} #{c} #{d}"
a, (b, c), d = [1, 2, 3, 4]
puts "a, b, c, d = #{a} #{b} #{c} #{d}"
a, (b, c), d = 1, [2, 3], 4
puts "a, b, c, d = #{a} #{b} #{c} #{d}"
a, (b, c), d = 1, [2, 3, 4], 5
puts "a, b, c, d = #{a} #{b} #{c} #{d}"
a, (b, *c), d = 1, [2, 3, 4], 5
puts "a, b, c, d = #{a} #{b} #{c} #{d}"

# 并行交换变量值
a, b = b, c
puts "------------------------------------------------------------------------------------------------------------------------------------------------"
puts "并行交换变量值"
puts "a, b, c: #{a} #{b} #{c}"

# 位运算符
a = 00111100 # 37440
b = 00001101 # 577
puts "------------------------------------------------------------------------------------------------------------------------------------------------"
puts "位运算符"
puts "a & b = #{a & b}"   # 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。
puts "a | b = #{a | b}"   # 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。
puts "a ^ b = #{a ^ b}"   # 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。
puts "~a =    #{~a}"      # 二进制补码运算符是一元运算符，具有"翻转"位效果，即0变成1，1变成0。
puts "a << 2 = #{a << 2}" # 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。
puts "a >> 2 = #{a >> 2}" # 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。

# 逻辑运算符
a, b = 10, 20
puts "------------------------------------------------------------------------------------------------------------------------------------------------"
puts "逻辑运算符"
puts "a and b:     #{a and b}"     # 称为逻辑与运算符。如果两个操作数都为真，则条件为真。
puts "a or b:      #{a or b}"      # 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。
puts "a && b:      #{a && b}"      # 称为逻辑与运算符。如果两个操作数都非零，则条件为真。
puts "a || b:      #{a || b}"      # 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。
puts "not(a && b): #{not(a && b)}" # 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。
puts "not(a && b): #{not(a && b)}" # 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。

# 三元运算符
a, b = 10, 20
puts "------------------------------------------------------------------------------------------------------------------------------------------------"
puts "三元运算符"
puts "a > b ? a : b = #{a > b ? a : b}" # 如果条件为真 ? 则值为 X : 否则值为 Y

# 范围运算符
a = 1..10  # 创建一个从开始点到结束点的范围（包含结束点）
b = 1...10 # 创建一个从开始点到结束点的范围（不包含结束点）

# defined? 运算符
# defined? 是一个特殊的运算符，以方法调用的形式来判断传递的表达式是否已定义。
# 它返回表达式的描述字符串，如果表达式未定义则返回 nil。
foo = 42
# 如果 variable 已经初始化，则为 True。未初始化，则返回空字符串
puts "------------------------------------------------------------------------------------------------------------------------------------------------"
puts "defined? 运算符"
puts "defined? variable: #{defined? variable}"
puts "defined? foo: #{defined? foo}"
puts "defined? $_:  #{defined? $_}"
puts "defined? bar: #{defined? bar}"
# 如果方法已经定义，则为 True。未初始化，则返回空字符串
puts "defined? method_call: #{defined? method_call}"
puts "defined? puts: #{defined? puts}"
puts "defined? puts(bar): #{defined? puts(bar)}"
puts "defined? unpack: #{defined? unpack}"
# 如果存在可被 super 用户调用的方法，则为 True
puts "defined? super: #{defined? super}"
# 如果已传递代码块，则为 True
puts "defined? yield: #{defined? yield}"

# 运算符 "."
# 可以通过在方法名称前加上类或模块名称和 . 来调用类或模块中的方法。

# 运算符 "::"
# 使用类或模块名称和两个冒号 "::" 来引用类或模块中的常量。
# "::" 是一元运算符，允许在类或模块内定义常量、实例方法和类方法，可以从类或模块外的任何地方进行访问。
# 在 Ruby 中，类和方法也可以被当作常量。
# 你只需要在表达式的常量名前加上 "::" 前缀，即可返回适当的类或模块对象。
# 如果 "::" 前的表达式为类或模块名称，则返回该类或模块内对应的常量值
# 如果 "::" 前未没有前缀表达式，则返回主 Object 类中对应的常量值。

# 运算符优先级
# 由高到底
# ::
# [][]=
# **
# ! ~ + -
# * / %
# + -
# >> <<
# &
# ^ |
# <= < > >=
# <=> == === != =~ !~
# ------ 以下方法不可被重载，以上方法可以被重载 -----------
# &&
# ||
# .. ...
# ? :
# = %= { /= -= += |= &= >>= <<= *= &&= ||= **=
# defined?
# not
# or and
